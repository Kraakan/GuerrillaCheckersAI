<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>flowchart_dqn.html</title>
        <style type="text/css">
          .end-element { fill : #FFCCFF; }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.17.1/flowchart.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.1/js/bootstrap.bundle.min.js"></script>
        <!-- <script src="../release/flowchart.min.js"></script> -->
        <script>

            window.onload = function () {
                var btn = document.getElementById("run"),
                    cd = document.getElementById("code"),
                    chart;
                    
                (btn.onclick = function () {
                    var code = cd.value;

                    if (chart) {
                      chart.clean();
                    }

                    chart = flowchart.parse(code);
                    chart.drawSVG('canvas', {
                      'x': 0,
                      'y': 0,
                      'line-width': 3,
                      //'maxWidth': 15,//ensures the flowcharts fits within a certain width
                      'line-length': 50,
                      'text-margin': 10,
                      'font-size': 14,
                      'font': 'normal',
                      'font-family': 'Helvetica',
                      'font-weight': 'normal',
                      'font-color': 'black',
                      'line-color': 'black',
                      'element-color': 'black',
                      'fill': 'white',
                      'yes-text': 'yes',
                      'no-text': 'no',
                      'arrow-end': 'block',
                      'scale': 1,
                      'symbols': {
                        'start': {
                          'font-size': 14,
                          'font-color': 'yellow',
                          'element-color': 'blue',
                          'fill': 'green',
                          'class': 'start-element'
                        },
                        'inputoutput': {
                          'font-color': 'black',
                          'element-color': 'black',
                          'fill': 'bisque'
                        },
                        'operation': {
                          'font-color': 'black',
                          'element-color': 'black',
                          'fill': 'linen'
                        },
                        'subroutine': {
                          'font-color': 'black',
                          'element-color': 'blue',
                          'fill': 'lightgreen'
                        },
                        'condition': {
                          'font-color': 'red',
                          'element-color': 'black',
                          'fill': 'yellow'
                        },
                        'end':{
                          'font-size': 20,
                          'class': 'end-element'
                        }
                      },
                      'flowstate' : {
                        //'past' : { 'fill' : '#CCCCCC', 'font-size' : 12},
                        //'current' : {'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'},
                        //'future' : { 'fill' : '#FFFF99'},
                        'request' : { 'fill' : 'blue'},
                        'invalid': {'fill' : '#444444'},
                        'approved' : { 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' },
                        'rejected' : { 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' }
                      }
                    });
                    //create base64 encoding of SVG to generate download link for title(without html or htm).SVG
                    var currentCanvasDIV = document.getElementById('canvas')
                    var currentDrawSVG = currentCanvasDIV.innerHTML.replaceAll('ë','e');

                    const OUTsvgBASE64 = btoa(currentDrawSVG)
                    doctitle = document.title.replace('.html','');
                    doctitle = doctitle.replace('.htm','');


                    var currentCanvasDIV = document.getElementById('canvas')
                    var currentDrawSVG = currentCanvasDIV.innerHTML.replaceAll('ë','e');
                    svgSource = currentDrawSVG
                    svgXML = currentDrawSVG;
                    // Use SVG Height and Width from the SVG XML to set canvas size
                    svgXMLsubstringHeight = svgXML.substring(svgXML.indexOf('height='), svgXML.indexOf('version='));
                    svgXMLsubstringWidth = svgXML.substring(svgXML.indexOf('width='), svgXML.indexOf('xmlns='));
                    HeightValue = svgXMLsubstringHeight.substring(svgXMLsubstringHeight.indexOf('"')+1,svgXMLsubstringHeight.lastIndexOf('"'));
                    WidthValue = svgXMLsubstringWidth.substring(svgXMLsubstringWidth.indexOf('"')+1,svgXMLsubstringWidth.lastIndexOf('"'));
                    HeightValueInt = Math.round(HeightValue)
                    WidthValueInt = Math.round(WidthValue)
                    // setup input for base64SvgToBase64Png
                    let svgSrc = "data:image/svg+xml;base64,"+OUTsvgBASE64;
                    var pngBase
                    imageUtil.base64SvgToBase64Png(svgSrc, WidthValueInt, HeightValueInt).then(pngSrc => {
                    pngBase = pngSrc
                    // output download link for base64 PNG converted on download from base64
                    var pngOutHtml = `<a href="${pngBase}" download="${doctitle}.png">PNG - Click here to download current rendered flowchart as ${doctitle}.png</a>`
                    document.getElementById("pngbase64").innerHTML=pngOutHtml;
                    });    
                    // output download link for base64 SVG converted on download from base64
                    var svgOutHtml = `<a href="data:image/svg+xml;base64,${OUTsvgBASE64}" download=${doctitle}.svg>SVG - Click here to download current rendered flowchart as ${doctitle}.svg</a> `
                        document.getElementById("svgbase64").innerHTML=svgOutHtml;
                    })();

                            };
                 

// derived from https://stackoverflow.com/a/64800570
// we need to use web browser canvas to generate a image. In this case png
let imageUtil = {};
/**
 * converts a base64 encoded data url SVG image to a PNG image
 * @param originalBase64 data url of svg image
 * @param width target width in pixel of PNG image
 * @param secondTry used internally to prevent endless recursion
 * @return {Promise<unknown>} resolves to png data url of the image
 */
imageUtil.base64SvgToBase64Png = function (originalBase64, width, height, secondTry) {
    return new Promise(resolve => {
        let img = document.createElement('img');
        img.onload = function () {
            if (!secondTry && (img.naturalWidth === 0 || img.naturalHeight === 0)) {
                let svgDoc = base64ToSvgDocument(originalBase64);
                let fixedDoc = fixSvgDocumentFF(svgDoc);
                return imageUtil.base64SvgToBase64Png(svgDocumentToBase64(fixedDoc), width, height, true).then(result => {
                    resolve(result);
                });
            }
            //document.body.appendChild(img);
            let canvas2 = document.createElement("canvas");
            //document.body.removeChild(img);
            canvas2.width = width;
            canvas2.height = height;
            let ctx = canvas2.getContext("2d");
            ctx.drawImage(img, 0, 0, canvas2.width, canvas2.height);
            try {
                let data = canvas2.toDataURL('image/png');
                resolve(data);
            } catch (e) {
                resolve(null);
            }
        };
        img.src = originalBase64;
    });
}

//needed because Firefox doesn't correctly handle SVG with size = 0, see https://bugzilla.mozilla.org/show_bug.cgi?id=700533
function fixSvgDocumentFF(svgDocument) {
    try {
        let widthInt = parseInt(svgDocument.documentElement.width.baseVal.value) || 500;
        let heightInt = parseInt(svgDocument.documentElement.height.baseVal.value) || 500;
        svgDocument.documentElement.width.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, widthInt);
        svgDocument.documentElement.height.baseVal.newValueSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX, heightInt);
        return svgDocument;
    } catch (e) {
        return svgDocument;
    }
}

function svgDocumentToBase64(svgDocument) {
    try {
        let base64EncodedSVG = btoa(new XMLSerializer().serializeToString(svgDocument));
        return 'data:image/svg+xml;base64,' + base64EncodedSVG;
    } catch (e) {
        return null;
    }
}

function base64ToSvgDocument(base64) {
    let svg = atob(base64.substring(base64.indexOf('base64,') + 7));
    svg = svg.substring(svg.indexOf('<svg'));
    let parser = new DOMParser();
    return parser.parseFromString(svg, "image/svg+xml");
} 
        </script>

        <script>
            function HelpText() {
              var x = document.getElementById("HelpTextBlock");
              if (x.style.display === "none") {
                x.style.display = "block";
              } else {
                x.style.display = "none";
              }
            }
        </script>
    </head>
    <body>
        <div><textarea id="code" style="width: 100%;" rows="11">op2=>operation: from gym_env import gym_env
op4=>operation: import guerrilla_checkers
op6=>operation: import math
op8=>operation: import random
op10=>operation: import copy
op12=>operation: import matplotlib
op14=>operation: import matplotlib.pyplot as plt
op16=>operation: from collections import namedtuple, deque
op18=>operation: from itertools import count
op20=>operation: import torch
op22=>operation: import torch.nn as nn
op24=>operation: import torch.optim as optim
op26=>operation: import torch.nn.functional as F
op28=>operation: player = None
cond31=>operation: player = int(input('Chose which player to train: 0 for COIN, 1 for Guerrilla. ')) while  (player not in [0, 1])
op43=>operation: env = gym_env(guerrilla_checkers.game(), player)
op45=>operation: is_ipython = ('inline' in matplotlib.get_backend())
cond48=>operation: from IPython import display if  is_ipython
sub58=>subroutine: plt.ion()
op60=>operation: device = torch.device(('cuda' if torch.cuda.is_available() else 'cpu'))
op62=>operation: Transition = namedtuple('Transition', ('state', 'action', 'next_state', 'reward'))
op64=>operation: class ReplayMemory(object):

    def __init__(self, capacity):
        self.memory = deque([], maxlen=capacity)

    def push(self, *args):
        'Save a transition'
        self.memory.append(Transition(*args))

    def sample(self, batch_size):
        return random.sample(self.memory, batch_size)

    def __len__(self):
        return len(self.memory)
op66=>operation: class DQN(nn.Module):

    def __init__(self, n_observations, n_actions):
        super(DQN, self).__init__()
        self.layer1 = nn.Linear(n_observations, 128)
        self.layer2 = nn.Linear(128, 128)
        self.layer3 = nn.Linear(128, n_actions)

    def forward(self, x):
        x = F.relu(self.layer1(x))
        x = F.relu(self.layer2(x))
        return self.layer3(x)
op68=>operation: BATCH_SIZE = 128
op70=>operation: GAMMA = 0.99
op72=>operation: EPS_START = 0.9
op74=>operation: EPS_END = 0.05
op76=>operation: EPS_DECAY = 1000
op78=>operation: TAU = 0.005
op80=>operation: LR = 0.0001
cond83=>condition: if (player == 1)
op87=>operation: n_actions = len(guerrilla_checkers.rules['all guerrilla moves'])
op89=>operation: action_list = list(guerrilla_checkers.rules['all guerrilla moves'].keys())
op98=>operation: state = env.reset()
op100=>operation: n_observations = len(state)
op102=>operation: policy_net = DQN(n_observations, n_actions).to(device)
op104=>operation: target_net = DQN(n_observations, n_actions).to(device)
sub106=>subroutine: target_net.load_state_dict(policy_net.state_dict())
op108=>operation: optimizer = optim.AdamW(policy_net.parameters(), lr=LR, amsgrad=True)
op110=>operation: memory = ReplayMemory(10000)
op112=>operation: steps_done = 0
st115=>start: start select_action
io117=>inputoutput: input: state
op120=>operation: global steps_done
op122=>operation: sample = random.random()
op124=>operation: eps_threshold = (EPS_END + ((EPS_START - EPS_END) * math.exp((((- 1.0) * steps_done) / EPS_DECAY))))
op126=>operation: steps_done += 1
op128=>operation: valid_action_indexes = env.game.get_valid_action_indexes(player)
cond131=>condition: if (sample > eps_threshold)
op135=>operation: with torch.no_grad():
    policy = policy_net(state)
    mask_tensor = torch.zeros(n_actions, dtype=torch.bool)
    for i in valid_action_indexes:
        mask_tensor[i] = True
    masked_policy = copy.copy(policy)
    masked_policy = torch.where(mask_tensor, masked_policy, torch.tensor((- 100000000.0)))
    max_i = masked_policy.max(1).indices.view(1, 1)
    return torch.tensor([[max_i]], device=device, dtype=torch.long)
e159=>end: end select_action
op162=>operation: episode_durations = []
st165=>start: start plot_durations
io167=>inputoutput: input: show_result
sub170=>subroutine: plt.figure(1)
op172=>operation: durations_t = torch.tensor(episode_durations, dtype=torch.float)
cond175=>condition: if show_result
sub179=>subroutine: plt.title('Result')
sub188=>subroutine: plt.xlabel('Episode')
sub190=>subroutine: plt.ylabel('Duration')
sub192=>subroutine: plt.plot(durations_t.numpy())
cond195=>condition: if (len(durations_t) >= 100)
op199=>operation: means = durations_t.unfold(0, 100, 1).mean(1).view((- 1))
op201=>operation: means = torch.cat((torch.zeros(99), means))
sub203=>subroutine: plt.plot(means.numpy())
sub208=>subroutine: plt.pause(0.001)
cond211=>condition: if is_ipython
cond216=>condition: if (not show_result)
sub220=>subroutine: display.display(plt.gcf())
sub222=>subroutine: display.clear_output(wait=True)
e232=>end: end plot_durations
st236=>start: start optimize_model
io238=>inputoutput: input: 
cond242=>condition: if (len(memory) < BATCH_SIZE)
e247=>end: end function return
op253=>operation: transitions = memory.sample(BATCH_SIZE)
op255=>operation: batch = Transition(*zip(*transitions))
op257=>operation: non_final_mask = torch.tensor(tuple(map((lambda s: (s is not None)), batch.next_state)), device=device, dtype=torch.bool)
op259=>operation: non_final_next_states = torch.cat([s for s in batch.next_state if (s is not None)])
op261=>operation: state_batch = torch.cat(batch.state)
op263=>operation: action_batch = torch.cat(batch.action)
op265=>operation: reward_batch = torch.cat(batch.reward)
op267=>operation: state_action_values = policy_net(state_batch).gather(1, action_batch)
op269=>operation: next_state_values = torch.zeros(BATCH_SIZE, device=device)
op271=>operation: with torch.no_grad():
    next_state_values[non_final_mask] = target_net(non_final_next_states).max(1).values
op273=>operation: expected_state_action_values = ((next_state_values * GAMMA) + reward_batch)
op275=>operation: criterion = nn.SmoothL1Loss()
op277=>operation: loss = criterion(state_action_values, expected_state_action_values.unsqueeze(1))
sub279=>subroutine: optimizer.zero_grad()
sub281=>subroutine: loss.backward()
sub283=>subroutine: torch.nn.utils.clip_grad_value_(policy_net.parameters(), 100)
sub285=>subroutine: optimizer.step()
e287=>end: end optimize_model
cond291=>condition: if torch.cuda.is_available()
op295=>operation: num_episodes = 5000
cond303=>condition: for i_episode in range(num_episodes)
op535=>operation: state = env.reset()
op537=>operation: state = torch.tensor(state, dtype=torch.float32, device=device).unsqueeze(0)
cond540=>operation: print('Running episode', (i_episode + 1)) if  ((i_episode % 50) == 0)
op550=>operation: terminated = False
cond553=>condition: while (not terminated)
op659=>operation: acting_player = env.get_acting_player()
cond662=>condition: if (len(env.game.get_valid_action_indexes(acting_player)) < 1)
sub666=>subroutine: breakpoint()
op668=>operation: terminated = True
op670=>operation: next_state = None
cond673=>condition: if (acting_player == env.player)
op677=>operation: reward = (- 1)
cond745=>condition: if terminated
op749=>operation: reward = env.game.get_reward(env.player)
sub751=>subroutine: episode_durations.append(reward)
sub753=>subroutine: plot_durations()
sub755=>subroutine: break
op681=>operation: reward = 1
cond687=>condition: if (acting_player == env.player)
op691=>operation: action = select_action(state)
op693=>operation: action_to_pass = action_list[action.item()]
op695=>operation: (observation, reward, terminated, truncated, _) = env.step(action_to_pass, acting_player)
op697=>operation: reward = torch.tensor([reward], device=device)
cond700=>condition: if terminated
op704=>operation: next_state = None
sub711=>subroutine: memory.push(state, action, next_state, reward)
op713=>operation: state = next_state
sub715=>subroutine: optimize_model()
op717=>operation: target_net_state_dict = target_net.state_dict()
op719=>operation: policy_net_state_dict = policy_net.state_dict()
cond722=>operation: target_net_state_dict[key] = ((policy_net_state_dict[key] * TAU) + (target_net_state_dict[key] * (1 - TAU))) while  key in policy_net_state_dict
sub734=>subroutine: target_net.load_state_dict(target_net_state_dict)
op708=>operation: next_state = torch.tensor(observation, dtype=torch.float32, device=device).unsqueeze(0)
op738=>operation: action = env.get_valid_sample()
op740=>operation: (observation, reward, terminated, truncated, _) = env.step(action, acting_player)
sub764=>subroutine: print('Complete')
sub766=>subroutine: plot_durations(show_result=True)
sub768=>subroutine: plt.ioff()
sub770=>subroutine: plt.show()
op299=>operation: num_episodes = 500
sub226=>subroutine: display.display(plt.gcf())
sub183=>subroutine: plt.clf()
sub185=>subroutine: plt.title('Training...')
cond140=>operation: breakpoint() if  (len(valid_action_indexes) < 1)
op150=>operation: random_action = random.choice(valid_action_indexes)
io155=>inputoutput: output:  torch.tensor([[random_action]], device=device, dtype=torch.long)
e153=>end: end function return
op93=>operation: n_actions = len(guerrilla_checkers.rules['all COIN moves'])
op95=>operation: action_list = list(guerrilla_checkers.rules['all COIN moves'].keys())

op2->op4
op4->op6
op6->op8
op8->op10
op10->op12
op12->op14
op14->op16
op16->op18
op18->op20
op20->op22
op22->op24
op24->op26
op26->op28
op28->cond31
cond31->op43
op43->op45
op45->cond48
cond48->sub58
sub58->op60
op60->op62
op62->op64
op64->op66
op66->op68
op68->op70
op70->op72
op72->op74
op74->op76
op76->op78
op78->op80
op80->cond83
cond83(yes)->op87
op87->op89
op89->op98
op98->op100
op100->op102
op102->op104
op104->sub106
sub106->op108
op108->op110
op110->op112
op112->st115
st115->io117
io117->op120
op120->op122
op122->op124
op124->op126
op126->op128
op128->cond131
cond131(yes)->op135
op135->e159
e159->op162
op162->st165
st165->io167
io167->sub170
sub170->op172
op172->cond175
cond175(yes)->sub179
sub179->sub188
sub188->sub190
sub190->sub192
sub192->cond195
cond195(yes)->op199
op199->op201
op201->sub203
sub203->sub208
sub208->cond211
cond211(yes)->cond216
cond216(yes)->sub220
sub220->sub222
sub222->e232
e232->st236
st236->io238
io238->cond242
cond242(yes)->e247
cond242(no)->op253
op253->op255
op255->op257
op257->op259
op259->op261
op261->op263
op263->op265
op265->op267
op267->op269
op269->op271
op271->op273
op273->op275
op275->op277
op277->sub279
sub279->sub281
sub281->sub283
sub283->sub285
sub285->e287
e287->cond291
cond291(yes)->op295
op295->cond303
cond303(yes)->op535
op535->op537
op537->cond540
cond540->op550
op550->cond553
cond553(yes)->op659
op659->cond662
cond662(yes)->sub666
sub666->op668
op668->op670
op670->cond673
cond673(yes)->op677
op677->cond745
cond745(yes)->op749
op749->sub751
sub751->sub753
sub753->sub755
cond745(no)->cond553
cond673(no)->op681
op681->cond745
cond662(no)->cond687
cond687(yes)->op691
op691->op693
op693->op695
op695->op697
op697->cond700
cond700(yes)->op704
op704->sub711
sub711->op713
op713->sub715
sub715->op717
op717->op719
op719->cond722
cond722->sub734
sub734->cond745
cond700(no)->op708
op708->sub711
cond687(no)->op738
op738->op740
op740->cond745
cond553(no)->cond303
cond303(no)->sub764
sub764->sub766
sub766->sub768
sub768->sub770
cond291(no)->op299
op299->cond303
cond216(no)->sub226
sub226->e232
cond211(no)->e232
cond195(no)->sub208
cond175(no)->sub183
sub183->sub185
sub185->sub188
cond131(no)->cond140
cond140->op150
op150->io155
io155->e153
cond83(no)->op93
op93->op95
op95->op98
</textarea></div>
        <div><button id="run" type="button">Run</button> <button onclick="HelpText()">Format Help</button></div>
        <div id="HelpTextBlock" style="display:none"><br/>Conditions can also be redirected like cond(yes, bottom) or cond(yes, right)
... and the other symbols too... like sub1(right)<br/>
You can also tweak the <b>diagram.drawSVG('diagram', {});</b> script in this file for more changes<br/>
This is based on <a href="https://github.com/adrai/flowchart.js">flowchart.js on github</a> and <a href="http://flowchart.js.org">http://flowchart.js.org</a> more documentation can be found over there.
</div><br/><div id="svgbase64"></div>
        <div id="pngbase64"></div>

        <div id="canvas"></div>
    </body>
</html>